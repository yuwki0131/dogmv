# Markdown Viewer 実装に関する Q&A

## 決定済み事項

### ✓ プログラミング言語
**決定**: Rust

---

## 技術選定に関する質問（Rust前提）

### Q1: GUIフレームワーク
**質問**: どのGUIフレームワークを採用しますか？

**Rust対応の選択肢**:

#### 1. **gtk4-rs** (GTK4のRustバインディング)
- **メリット**:
  - Waylandネイティブ対応、Hyprlandとの相性良好
  - 豊富なウィジェット、成熟したエコシステム
  - NixOSでのビルドサポートが充実
  - WebKitGTKと連携してWebViewレンダリング可能
- **デメリット**:
  - FFIバインディングのため、純粋なRustではない
  - 依存関係が多い（GTK4本体が必要）

#### 2. **Iced**
- **メリット**:
  - 純粋なRust実装、型安全性高い
  - Elm風の宣言的UI、状態管理がシンプル
  - wgpu/Vulkan/OpenGLバックエンド選択可能
  - クロスプラットフォーム
- **デメリット**:
  - WebViewサポートが限定的（自前でWebレンダリングが必要）
  - GTK4ほど成熟していない
  - リッチテキストレンダリングが複雑

#### 3. **egui**
- **メリット**:
  - 軽量、イミディエイトモード
  - シンプルなAPI、学習コスト低い
  - wgpuバックエンドでWayland対応
- **デメリット**:
  - WebViewサポートなし
  - Markdownレンダリングを全て自前実装が必要

#### 4. **Slint**
- **メリット**:
  - QMLライクな宣言的UI
  - 軽量、組み込みにも対応
- **デメリット**:
  - Markdownレンダリングの実装例が少ない
  - エコシステムがGTK/Icedより小さい

#### 5. **relm4** (GTK4のRustラッパー)
- **メリット**:
  - gtk4-rsより高レベルなAPI
  - Elmライクな設計でIcedに近い使い勝手
  - GTK4の恩恵を受けつつRustらしい記述
- **デメリット**:
  - gtk4-rsの上に構築されるため、学習コストが二重

**推奨**:
- **WebViewレンダリング採用なら**: `gtk4-rs` または `relm4` (WebKitGTK連携が容易)
- **ネイティブレンダリング採用なら**: `Iced` (純粋Rust、柔軟性高い)

**回答**: gtk4-rsを採用で。

---

### Q2: Markdownパーサー/レンダラー
**質問**: どのMarkdownライブラリを使用しますか？

**Rustの選択肢**:

#### 1. **comrak**
- GitHub Flavored Markdown完全対応
- テーブル、タスクリスト、取り消し線など拡張機能豊富
- HTMLへの変換が容易
- シンタックスハイライト用のコールバック対応
- **推奨**: 機能豊富で実用的

#### 2. **pulldown-cmark**
- 高速、CommonMark厳密準拠
- 軽量、依存少ない
- イベントベースのパーサー（カスタマイズ性高い）
- GFM拡張は限定的（別途`pulldown-cmark-gfm`必要）
- **推奨**: シンプルな実装向け

#### 3. **markdown-rs**
- CommonMark完全実装
- モダンな設計
- エコシステムがやや小さい

**決定**: `comrak` (GFM対応、拡張性、実績から)

---

## 機能要件に関する質問

### Q5: ファイル監視機能
**質問**: ファイルが外部エディタで変更された際、自動的にリロードしますか？

**Rust実装における選択肢**:

#### 1. **notify** crate使用（自動リロード）
- クロスプラットフォームなファイル監視
- inotify (Linux) 使用で低オーバーヘッド
- **実装**: 非同期タスクでファイル変更監視 → UIに通知
- **メリット**: ライブプレビュー体験
- **デメリット**: 頻繁な変更時のパフォーマンス影響

#### 2. 手動リロードのみ
- `Ctrl+R`やリロードボタン
- **メリット**: シンプル、予測可能
- **デメリット**: 手動操作が必要

#### 3. 変更検知 + 通知バー
- ファイル変更を検知してバナー表示
- ユーザーがクリックでリロード
- **メリット**: 自動/手動のバランス
- **推奨**: 初期実装向け

**推奨**: **notify + 自動リロード**（開発体験向上のため）

**回答**: **notify + 自動リロード**（開発体験向上のため）でOKです。
---

### Q3: レンダリング方式
**質問**: HTMLレンダリング方式は？

**Rust実装における選択肢**:

#### A. **WebView方式** (webkit2gtk-rs使用)
- **実装**:
  1. `comrak`でMarkdown → HTML変換
  2. `webkit2gtk-rs`でHTMLレンダリング
- **メリット**:
  - CSSによるスタイリング容易
  - 画像、リンク、テーブルの表示が簡単
  - ブラウザと同じ見た目
- **デメリット**:
  - WebKitGTKの依存必須（サイズ大）
  - GTK4前提（他のフレームワークと組み合わせ困難）
- **推奨ケース**: GTK4採用時、開発速度優先

#### B. **ネイティブウィジェット方式** (GTKウィジェット直接)
- **実装**:
  1. `comrak`のイベントパーサーを使用
  2. GTKの`TextView`, `Label`, `Image`等でレンダリング
- **メリット**:
  - WebKit不要、軽量
  - システムテーマと完全統合
- **デメリット**:
  - 実装が複雑（リッチテキスト処理）
  - CSSが使えない
- **推奨ケース**: 軽量化優先、WebKit依存を避けたい場合

#### C. **カスタムレンダリング** (wgpu + コスモポリタン2D)
- **実装**:
  1. Iced/eguiのカスタムウィジェット
  2. `cosmic-text`などでテキストレンダリング
  3. 独自のレイアウトエンジン
- **メリット**:
  - 完全な制御、最適化可能
  - GTK不要、純粋Rust
- **デメリット**:
  - 実装コストが極めて高い
  - 画像、テーブル等の実装が困難
- **推奨ケース**: 高度なカスタマイズ、将来的な拡張性重視

**推奨**: **WebView方式（GTK4 + webkit2gtk-rs）**
- 理由: 開発速度、機能性、NixOS/Hyprlandとの親和性

**回答**: 推奨されているA案で大丈夫です。

---

### Q4: シンタックスハイライト
**質問**: コードブロックのシンタックスハイライトをどう実装しますか？

**Rust実装における選択肢**:

#### 1. **syntect** (WebView方式で推奨)
- Sublime Textのシンタックス定義（.sublime-syntax）使用
- 200以上の言語サポート
- HTML出力が容易（`<span class="...">`でマークアップ）
- **統合例**: `comrak` → `syntect`でコードブロック処理 → HTMLに埋め込み
- **推奨**: WebViewレンダリング採用時

#### 2. **tree-sitter** + カスタムハイライト
- 高速、正確な構文解析
- インクリメンタルパース可能
- **課題**: HTML変換やスタイリングを自前実装必要
- **推奨**: ネイティブレンダリング採用時

#### 3. **highlight.js** (WebView内で実行)
- JavaScript実装、WebView内で動作
- CDNから読み込み可能
- **メリット**: Rust側の実装不要
- **デメリット**: JSに依存、ビルドサイズ増
- **推奨**: 最小限の実装で済ませたい場合

#### 4. ハイライトなし
- コードブロックをモノスペースフォントで表示のみ

**推奨**: **syntect**（WebView方式採用時）
**回答**: 推奨されている1案(syntect)で大丈夫です。

---

## NixOS固有の質問

### Q6: Nixパッケージング
**質問**: どのようにパッケージングしますか？

**Rust + Nixの選択肢**:

#### 1. **flake.nix + Cargo.toml** (推奨)
- `crane`を使用したRustビルド
- Cargoの依存解決 + Nixの再現性
- **構成**:
  - `flake.nix`: パッケージ定義、開発環境
  - `Cargo.toml/Cargo.lock`: Rust依存管理
- **メリット**: 両エコシステムの利点を活用

#### 2. `buildRustPackage`のみ
- nixpkgs標準のRustビルド
- **メリット**: シンプル
- **デメリット**: `crane`より柔軟性低い

**推奨**: **flake.nix (crane) + shell.nix**
**回答**: 推奨されている1案(flake.nix/cargo.toml)で大丈夫です。
---

### Q7: システムライブラリ依存（GTK4採用時）
**質問**: GTK4/WebKitGTKなどのシステムライブラリをどう扱いますか？

**Nixでの実装**:
```nix
buildInputs = [
  gtk4
  webkitgtk_6_0
  pkg-config
];
```

**確認事項**:
- GTK4のWaylandバックエンドが有効か（NixOSではデフォルト有効）

- `webkitgtk_6_0`の利用可否（GTK4対応版）
- Hyprland環境変数（`GDK_BACKEND=wayland`）

**推奨**: `shell.nix`と`flake.nix`両方でビルド依存を明記

---

## UI/UX に関する質問

### Q8: ウィンドウレイアウト
**質問**: UIレイアウトは？

**選択肢**:

#### 1. **プレビュー単一画面**
- ファイルオープン → 全画面プレビュー表示
- ファイル選択は`FileChooserDialog`またはCLI引数
- **メリット**: シンプル、Unix哲学（ファイルマネージャと分離）
- **推奨**: 初期実装向け

#### 2. **サイドバー付き**
- 左: ファイルツリー、右: プレビュー
- **メリット**: 複数ファイル切り替えが容易
- **デメリット**: 実装複雑化

#### 3. **分割ビュー（エディタ + プレビュー）**
- 左: テキストエディタ、右: プレビュー
- **課題**: エディタ実装が必要（スコープ拡大）
- **推奨しない**: Viewerの範囲を超える

**推奨**: **プレビュー単一画面**
**回答**: 初期実装は1のプレビュー単一画面とします。ただし将来的にはサイドバー(左にファイルツリー)をつける予定です。
---

### Q9: テーマ・スタイリング
**質問**: 見た目のカスタマイズ性は？

**GTK4実装の場合**:

#### 1. **GTKテーマ追従** (推奨)
- `gtk4::Settings::default()`でシステムテーマ自動適用
- Adwaita、Adwaita-dark等に対応
- **実装**: 特別な設定不要

#### 2. **カスタムCSS**
- GTK4の`CssProvider`でスタイル上書き
- Markdown表示部分のフォント、色をカスタマイズ
- **例**: コードブロックの背景色、フォントサイズ
- **実装**: `style.css`を読み込み

#### 3. **WebView内CSS** (WebView採用時)
- HTMLに`<style>`タグでCSS注入
- `webkit2gtk`の`load_html`時にスタイル適用
- **推奨**: GitHub風スタイルなど選択可能にする

**推奨**: **GTKテーマ追従 + WebView内カスタムCSS**
**回答**: WebView内CSSとしてください。
---

### Q11: キーボードショートカット
**質問**: どのようなキーバインドを実装しますか？
**例**:
- `Ctrl+O`: ファイルを開く
- `Ctrl+R`: リロード
- `Ctrl+Q`: 終了
- `Ctrl++/-`: ズーム

**不明点**: Hyprland固有のキーバインドとの競合回避
**回答**: 初期実装では以下のみ実装してください。ただし、将来的にはキーショートカットの拡充(変更)を行います
- `Ctrl+O`: ファイルを開く
- `Ctrl+R`: リロード
- `Ctrl+Q`: 終了

---

## パフォーマンス・最適化

### Q12: 大規模ファイル対応
**質問**: 大きなMarkdownファイル（数MB以上）の扱いは？
**考慮点**:
- 遅延レンダリング
- 仮想スクロール
- ファイルサイズ制限

**不明点**: 実用上の最大ファイルサイズ目安
**回答**:2000行(60k程度)を目安にしてください。平均は100〜1000行程度のmarkdownを開く想定です。
---

### Q13: メモリ管理
**質問**: 画像やアセットのキャッシュ戦略は？
**選択肢**:
- メモリキャッシュ
- ディスクキャッシュ
- キャッシュなし

**回答**: メモリキャッシュ

---

## 拡張機能・将来計画

### Q14: プラグイン機構
**質問**: 将来的にプラグインや拡張機能をサポートしますか？
**例**:
- カスタムMarkdown拡張
- テーマプラグイン
- エクスポート機能

**回答**: プラグイン拡張はしない(想定しない)でお願いします。

---

### Q15: エクスポート機能
**質問**: MarkdownをPDF/HTML/その他形式にエクスポートしますか？
**優先度**: 低〜中

**回答**: エクスポートは不要です。純粋なViewのみの機能を提供します。

---

## 開発プロセス

### Q16: テスト戦略
**質問**: どのようなテストを実施しますか？
**種類**:
- ユニットテスト（Markdownパース、レンダリングロジック）
- 統合テスト
- GUIテスト（難易度高）

**回答**: ひとまずUnitテストでお願いします。

---

### Q17: CI/CD
**質問**: 継続的インテグレーションを設定しますか？
**選択肢**:
- GitHub Actions（Nix環境でのビルド）
- 手動ビルド

**回答**: 将来的にはGitHub Actionsでの稼働を想定しますが、一旦初期実装はローカルの手動ビルドを想定してください。

---

## アプリケーション仕様の詳細

### Q18: CLI引数仕様
**質問**: コマンドライン引数の仕様はどうしますか？

**選択肢**:

#### 1. ファイルパス指定
```bash
dogmv <file.md>
dogmv /path/to/document.md
```
- 引数でファイルパスを受け取り、そのファイルを開く

#### 2. 引数なしの場合
- **A**: ファイル選択ダイアログ（GTK FileChooserDialog）を表示
- **B**: エラーメッセージ表示して終了
- **C**: 空のウィンドウ表示、Ctrl+Oでファイルを開く

#### 3. 複数ファイル対応
```bash
dogmv file1.md file2.md file3.md
```
- 初期実装では不要？
- 将来的にタブ機能と組み合わせ？

**推奨**:
- `dogmv <file.md>` でファイル直接開く
- 引数なしの場合はファイルダイアログ表示
- 複数ファイルは初期実装では非対応

**回答**: 引数ありでファイルパス指定のみ可としてください。それ以外の引数は不要です。また、初期実装では複数ファイル対応も不要です。

---

### Q19: エラーハンドリング
**質問**: エラーケースの扱いはどうしますか？

**エラーケース**:

#### 1. 存在しないファイルパス
```bash
dogmv non_existent.md
```
- **A**: エラーダイアログ表示 + ファイル選択ダイアログ
- **B**: stderr出力して終了
- **C**: エラーダイアログ表示して終了

#### 2. Markdown以外のファイル
```bash
dogmv document.txt
dogmv image.png
```
- **A**: 拡張子チェックせず、テキストとして開く（寛容）
- **B**: `.md`, `.markdown`のみ受け付ける（厳格）
- **C**: 警告を出すが開く

#### 3. 読み込み権限がないファイル
- **A**: エラーダイアログ表示
- **B**: stderr出力して終了

#### 4. 破損したMarkdown/不正なUTF-8
- **A**: ベストエフォートでレンダリング（comrakのデフォルト動作）
- **B**: エラー表示

**推奨**:
- 存在しないファイル: エラーダイアログ + ファイル選択ダイアログ
- Markdown以外: 拡張子チェックせず開く（寛容）
- 権限エラー: エラーダイアログ表示
- 破損データ: ベストエフォートでレンダリング

**回答**: 存在しないファイルの場合はエラーログ出力でダウン(プロセスを中断し終了)で大丈夫です。Markdown以外のファイルを開くことを試みた場合、権限エラー、破損データの場合もエラーログ出力で強制中断で大丈夫です。ただし、単にMarkdownフォーマットとして崩れている場合はそのまま生テキストとして表示させてください。

---

### Q20: 画像パスの解決
**質問**: Markdown内の画像パス（相対パス/絶対パス）の扱いはどうしますか？

**パターン**:

#### 1. 相対パス
```markdown
![](./images/foo.png)
![](../assets/bar.png)
```
- **基準ディレクトリ**: 開いたMarkdownファイルの親ディレクトリ
- WebView内で`file://`スキームで解決

#### 2. 絶対パス
```markdown
![](/home/user/images/baz.png)
```
- そのまま解決

#### 3. HTTP/HTTPS URL
```markdown
![](https://example.com/image.png)
```
- **A**: WebViewで自動ダウンロード・表示（WebKitの機能）
- **B**: セキュリティ理由で無効化
- **C**: 設定で切り替え可能

#### 4. ベースURL設定
- HTMLレンダリング時に`<base href="file:///path/to/markdown/dir/">`を設定
- 相対パス解決を自動化

**推奨**:
- 相対パス: Markdownファイルのディレクトリを基準に解決
- 絶対パス: そのまま使用
- HTTP/HTTPS: WebViewデフォルト動作（表示する）
- `<base>`タグで自動解決

**回答**: 相対パスで。

---

### Q21: ウィンドウサイズ・状態の保存
**質問**: ウィンドウのサイズや位置を記憶しますか？

**選択肢**:

#### 1. 状態保存あり
- 前回のウィンドウサイズ、位置を保存
- 保存先: `~/.config/dogmv/window.conf` など
- GTK4の`gtk::Window::save_size()`使用

#### 2. 状態保存なし
- 常にデフォルトサイズで起動（例: 1024x768）

#### 3. 最後に開いたファイルを記憶
- 引数なし起動時に前回のファイルを開く

**推奨**:
- 初期実装: 状態保存なし（デフォルトサイズ）
- 将来: ウィンドウサイズ保存

**回答**: 状態保存なしで。

---

### Q22: ログ出力・デバッグ
**質問**: ログ出力の方針は？

**選択肢**: ログは起動したターミナルに直接出力してください。

#### 1. ログライブラリ
- **env_logger**: 環境変数`RUST_LOG=debug`でログレベル制御
- **tracing**: 構造化ログ、デバッグに有用

#### 2. ログ出力先
- **A**: stdout/stderr
- **B**: ファイル (`~/.cache/dogmv/dogmv.log`)

#### 3. ログレベル
- エラー、警告、情報、デバッグ

**推奨**:
- `env_logger` + `log` crate
- stdout/stderr出力
- `RUST_LOG=dogmv=debug`で詳細ログ

**回答**:ログレベルは一旦初期実装ではエラー、警告、情報、デバッグログまで全部出力で問題ないです。出力先も標準出力でOKです。

---

---

## 決定事項まとめ（ユーザー入力待ち）

### ✓ 確定済み
- **言語**: Rust
- **Markdownパーサー**: comrak

### ⚠ 決定が必要な重要事項

以下の項目について決定をお願いします：

#### 1. **GUIフレームワーク** (Q1)
- [ ] **gtk4-rs** (WebView連携容易、NixOS親和性高)
- [ ] **Iced** (純粋Rust、カスタマイズ性高)
- [ ] **その他** (relm4, egui, Slint)

#### 2. **レンダリング方式** (Q3)
- [ ] **WebView** (webkit2gtk-rs、開発速度優先)
- [ ] **ネイティブウィジェット** (GTK4ウィジェット直接、軽量)
- [ ] **カスタムレンダリング** (高度、実装コスト大)

#### 3. **その他の方針** (任意)
- ファイル監視: 自動リロード / 手動 / 通知バー (推奨: 自動)
- シンタックスハイライト: あり / なし (推奨: syntect使用)
- ウィンドウレイアウト: 単一画面 / サイドバー (推奨: 単一)


回答は各セクションに記載しました。各セクションの内容を確認してください。

---

### 推奨構成（迷った場合）
```
言語: Rust
GUIフレームワーク: gtk4-rs
レンダリング: WebView (webkit2gtk-rs)
Markdownパーサー: comrak
シンタックスハイライト: syntect
ファイル監視: notify (自動リロード)
レイアウト: プレビュー単一画面
パッケージング: flake.nix + Cargo
```

この構成なら、NixOS/Hyprland環境で実用的なMarkdownビューアが実装できます。

---

## ディレクトリツリー機能 (TreeView/Sidebar) に関する質問

### Q23: ディレクトリツリー機能の基本仕様
**質問**: 左側に表示するディレクトリツリーの基本的な仕様はどうしますか？

**検討事項**:

#### 1. 表示範囲
- **A**: 開いたMarkdownファイルの親ディレクトリのみ表示
- **B**: 開いたMarkdownファイルからカレントディレクトリまで遡って表示
- **C**: ユーザーが指定した任意のディレクトリをルートとして表示
- **D**: ホームディレクトリ全体を表示（~/から）

**推奨**: **A** (親ディレクトリのみ表示) - シンプルで実用的

#### 2. ファイルフィルタリング
- **A**: Markdownファイル(.md, .markdown)のみ表示
- **B**: テキストファイル全般を表示(.txt, .md, .rst等)
- **C**: すべてのファイルを表示（画像等も含む）
- **D**: ユーザーが設定可能

**推奨**: **A** (Markdownファイルのみ) - ビューアの目的に特化

#### 3. ディレクトリの再帰表示
- **A**: 1階層のみ表示（親ディレクトリの直下のみ）
- **B**: すべてのサブディレクトリを再帰的に表示
- **C**: 展開可能なツリー形式（折りたたみ可能）

**推奨**: **C** (展開可能なツリー) - 柔軟性と見やすさのバランス

**回答**:表示範囲ですが、ユーザーが指定した任意のディレクトリをルートとして表示してください。「ユーザーが指定したディレクトリ」はコマンドライン引数からディレクトリを指定した場合の挙動とします。ユーザーがファイルを指定して開いた場合は、A案の開いたmarkdownファイルの親ディレクトリのみ表示という仕様としてください。ファイルフィルタリングはすべてのファイルを表示させてください。markdownファイル以外のファイルを開こうとした場合は、「何もしない」(ファイルを開かないし、開いているファイルはそのままとする)振る舞いとしてください。ディレクトリの再起表示ですが、展開可能なツリー形式としてください。

---

### Q24: UIレイアウト・ウィジェット構成
**質問**: サイドバーとメインビューのレイアウト構成はどうしますか？

**GTK4実装の選択肢**:

#### 1. **gtk4::Paned使用** (分割ペイン)
```rust
let paned = gtk4::Paned::new(gtk4::Orientation::Horizontal);
paned.set_start_child(Some(&tree_view));    // 左: ツリー
paned.set_end_child(Some(&webview));        // 右: プレビュー
paned.set_position(250);                    // 初期幅250px
```
- **メリット**: ユーザーがドラッグでサイズ調整可能
- **デメリット**: なし
- **推奨**: 最も標準的な実装

#### 2. **gtk4::Box使用** (固定サイズ)
```rust
let hbox = gtk4::Box::new(gtk4::Orientation::Horizontal, 0);
hbox.append(&tree_view);
hbox.append(&webview);
```
- **メリット**: シンプル
- **デメリット**: サイズ固定、柔軟性低い

#### 3. **gtk4::Stack + StackSwitcher** (切り替え式)
- ツリービューとプレビューを切り替え表示
- **メリット**: 小画面向け
- **デメリット**: 同時表示不可

**推奨**: **1 (gtk4::Paned)** - 一般的なIDEと同様のUX

**回答**:1案でお願いします。

---

### Q25: ツリービューの実装方式
**質問**: ディレクトリツリーの実装にどのGTK4ウィジェットを使用しますか？

**選択肢**:

#### 1. **gtk4::TreeView** (伝統的)
- GTK3時代からあるウィジェット
- `gtk4::TreeStore`でデータ管理
- **メリット**: 実績豊富、例が多い
- **デメリット**: GTK4では非推奨傾向、パフォーマンス面で劣る

#### 2. **gtk4::ListView + gtk4::TreeListModel** (GTK4推奨)
- GTK4の新しいリストウィジェット
- モデル/ビューの明確な分離
- **メリット**: パフォーマンス良好、GTK4の推奨実装
- **デメリット**: 学習コスト高め、例が少ない
- **推奨**: モダンな実装向け

#### 3. **gtk4::ColumnView + TreeListModel**
- 複数カラム表示可能（名前、更新日時等）
- **メリット**: 情報量が多い
- **デメリット**: 複雑、ファイル名だけなら過剰

**推奨**: **2 (ListView + TreeListModel)** - GTK4のベストプラクティス

**回答**:2案でお願いします。

---

### Q26: ツリービューの表示内容
**質問**: ツリービューに表示する情報はどうしますか？

**表示項目候補**:

#### 1. **ファイル名のみ**
```
📁 docs/
  📄 README.md
  📄 INSTALL.md
📁 src/
  📄 main.rs
```
- シンプル、見やすい

#### 2. **ファイル名 + アイコン**
- ディレクトリアイコン、ファイルアイコンで視覚的に区別
- **実装**: `gio::ThemedIcon`やカスタムアイコン

#### 3. **ファイル名 + 更新日時/サイズ**
```
README.md    2025-10-20  1.2KB
```
- 情報量多い
- **デメリット**: 幅が必要

**推奨**: **2 (ファイル名 + アイコン)** - 視認性とシンプルさのバランス

**回答**: 2案でお願いします。

---

### Q27: ファイル操作機能
**質問**: ツリービューからどのような操作を可能にしますか？

**操作候補**:

#### 1. **クリックでファイルを開く**
- シングルクリックでプレビュー更新
- **必須機能**

#### 2. **ダブルクリックで外部エディタを開く**
- デフォルトエディタ(`xdg-open`)で編集
- **実装**: `std::process::Command::new("xdg-open")`

#### 3. **右クリックメニュー**
- 「エディタで開く」
- 「ファイルマネージャで表示」
- 「パスをコピー」
- **実装**: `gtk4::PopoverMenu`

#### 4. **ディレクトリの展開/折りたたみ**
- ツリー構造の展開制御
- **必須機能**

#### 5. **ファイルのドラッグ&ドロップ**
- 他アプリへのファイルパス共有
- **優先度**: 低

**推奨**:
- **必須**: 1, 4
- **推奨**: 2, 3
- **オプション**: 5

**回答**:1, 4案のみの実装で大丈夫です。

---

### Q28: ツリービューの更新・同期
**質問**: ディレクトリ内のファイルが外部で追加/削除された際の対応はどうしますか？

**選択肢**:

#### 1. **自動更新**
- `notify`でディレクトリを監視
- ファイル追加/削除/リネームを検知してツリーを更新
- **メリット**: リアルタイム性
- **デメリット**: 実装複雑、パフォーマンス影響

#### 2. **手動更新**
- リフレッシュボタンまたはキーボードショートカット(F5等)
- **メリット**: シンプル
- **デメリット**: ユーザー操作必要

#### 3. **フォーカス時に更新**
- ウィンドウがフォーカスを得た際に自動更新
- **メリット**: 自動/手動の中間
- **デメリット**: タイミングが限定的

**推奨**: **2 (手動更新)** → 将来的に1へ移行

**回答**: 2案でお願いします。リフレッシュは、Ctrl+Rでリロード(リフレッシュ)としてください。

---

### Q29: サイドバーの表示/非表示切り替え
**質問**: サイドバーを非表示にする機能は必要ですか？

**選択肢**:

#### 1. **切り替え可能**
- キーボードショートカット (例: Ctrl+B, F9)
- メニューバー/ツールバーのトグルボタン
- **実装**: `gtk4::Paned`の`set_visible()`

#### 2. **常に表示**
- トグル機能なし
- **メリット**: シンプル

**推奨**: **1 (切り替え可能)** - 小画面や全画面プレビュー時に便利

**回答**: 切り替え可能としてください。トグルボタンを配置し、ボタン押下で切り替えとしましょう。

---

### Q30: 初期表示時のディレクトリ
**質問**: アプリ起動時にどのディレクトリをツリーのルートとして表示しますか？

**選択肢**:

#### 1. **開いたファイルの親ディレクトリ**
```bash
dogmv ~/docs/project/README.md
# → ~/docs/project/ をルートとして表示
```
- **メリット**: 関連ファイルに即座にアクセス可能
- **推奨**

#### 2. **カレントワーキングディレクトリ**
```bash
cd ~/docs/project
dogmv README.md
# → ~/docs/project/ を表示
```
- **メリット**: 予測可能
- **デメリット**: 絶対パス指定時に不便

#### 3. **固定ディレクトリ (例: ~/Documents/)**
- **デメリット**: 柔軟性がない

**推奨**: **1 (ファイルの親ディレクトリ)** - 最も実用的

**回答**: ユーザーが引数にディレクトリ指定した場合は、そのディレクトリ、ファイル名を指定した場合は、指定したファイルの親ディレクトリとしてください。

---

### Q31: ツリービューの幅・サイズ
**質問**: サイドバーの初期幅と調整方法はどうしますか？

**選択肢**:

#### 1. **固定幅 (例: 200px, 250px)**
- シンプル
- **デメリット**: 長いファイル名が見切れる

#### 2. **可変幅 (Panedでドラッグ調整可能)**
- ユーザーが調整可能
- **推奨**

#### 3. **幅を保存 (設定ファイル)**
- 前回の幅を記憶
- **実装**: `~/.config/dogmv/settings.toml`等
- **優先度**: 低 (後回し可)

**推奨**: **2 (可変幅)** - 標準的なUI

**初期幅の推奨値**: 250px

**回答**: 可変幅としてください。

---

### Q32: ソート順
**質問**: ツリービュー内のファイル/ディレクトリの並び順はどうしますか？

**選択肢**:

#### 1. **ディレクトリ優先 + 名前順**
```
📁 assets/
📁 docs/
📁 src/
📄 CHANGELOG.md
📄 README.md
```
- **推奨**: 一般的なファイルマネージャと同じ

#### 2. **名前順のみ (ディレクトリと混在)**
- ディレクトリを特別扱いしない

#### 3. **更新日時順**
- 最近編集したファイルが上
- **デメリット**: ツリー構造と相性悪い

**推奨**: **1 (ディレクトリ優先 + 名前順、アルファベット順)**

**回答**: 1案でお願いします

---

### Q33: 隠しファイル・隠しディレクトリの扱い
**質問**: `.git`, `.config`などの隠しファイル/ディレクトリを表示しますか？

**選択肢**:

#### 1. **非表示 (デフォルト)**
- `.*`で始まるファイル/ディレクトリを除外
- **推奨**: 大半のユースケース向け

#### 2. **表示**
- すべて表示
- **デメリット**: ノイズが多い

#### 3. **トグル可能**
- ショートカットやメニューで切り替え
- **メリット**: 柔軟性高い
- **デメリット**: 実装コスト増

**推奨**: **1 (非表示)** → 将来的に3へ移行可

**回答**: 1案で良いです。

---

### Q34: エラーハンドリング (ツリービュー)
**質問**: ディレクトリ読み込みエラー時の対応はどうしますか？

**エラーケース**:

#### 1. **権限エラー (Permission denied)**
- ディレクトリに読み取り権限がない
- **対応A**: エラーアイコン表示 + ツールチップでエラー内容
- **対応B**: ログ出力のみ、ツリーには表示しない

#### 2. **ディレクトリが存在しない**
- ファイル削除後など
- **対応**: エラーダイアログ + ツリーを空にする

#### 3. **シンボリックリンクの扱い**
- **A**: シンボリックリンクを辿る
- **B**: シンボリックリンク自体を表示
- **C**: 無視

**推奨**:
- 権限エラー: ログ出力のみ
- 存在しないディレクトリ: エラーログ + 空ツリー
- シンボリックリンク: 辿る (無限ループ検出を実装)

**回答**: 権限エラーと存在しないディレクトリは、推奨案でお願いします。シンボリックリンクは辿らなくてカッコ付で名前の後ろにシンボリックリンク(symlink)と記載してください。シンボリックリンクは展開しない。押下しても反応しないという振る舞いで大丈夫です。

---

### Q35: パフォーマンス考慮
**質問**: 大量のファイルがあるディレクトリの扱いはどうしますか？

**考慮点**:

#### 1. **ファイル数制限**
- 1ディレクトリあたりの表示上限 (例: 1000ファイル)
- 超過時は警告表示
- **推奨**: 初期実装で制限設定

#### 2. **遅延読み込み**
- ディレクトリ展開時に初めてサブディレクトリを読み込む
- **メリット**: 初期表示が高速
- **実装**: `TreeListModel`の遅延展開機能

#### 3. **バックグラウンド読み込み**
- 別スレッドでディレクトリスキャン
- **デメリット**: 実装複雑

**推奨**: **2 (遅延読み込み)** - TreeListModelの標準機能

**回答**:2案でお願いします

---

### Q36: キーボードナビゲーション
**質問**: ツリービュー内のキーボード操作はどうしますか？

**操作候補**:

#### 1. **矢印キー**
- ↑↓: ファイル/ディレクトリ間を移動
- →: ディレクトリ展開
- ←: ディレクトリ折りたたみ
- **実装**: GTK4のデフォルト動作

#### 2. **Enter/Space**
- Enter: ファイルを開く
- Space: ディレクトリ展開/折りたたみ切り替え

#### 3. **文字入力で検索**
- 'r'を押すと"README.md"にジャンプ
- **実装**: GTK4の`enable_search()`

**推奨**: **1, 2, 3すべて実装** (GTK4の標準機能で容易)

**回答**:推奨案でお願いします

---

### Q37: 現在開いているファイルの強調表示
**質問**: ツリービューで現在開いているファイルをどう表示しますか？

**選択肢**:

#### 1. **強調表示 (ハイライト)**
- 背景色変更、太字、色変更等
- **実装**: `TreeListRow`のカスタムレンダリング

#### 2. **アイコン追加**
- 開いているファイルの隣に"▶"や"●"を表示

#### 3. **何もしない**
- 特別な表示なし

**推奨**: **1 (強調表示)** - ユーザビリティ向上

**回答**:推奨案でお願いします

---

### Q38: 実装優先度
**質問**: ディレクトリツリー機能をどの順序で実装しますか？

**フェーズ提案**:

#### フェーズA (最小限の機能)
- [ ] `gtk4::Paned`でサイドバー配置
- [ ] `ListView + TreeListModel`で基本ツリー表示
- [ ] ファイルクリックでプレビュー更新
- [ ] ディレクトリ展開/折りたたみ
- [ ] Markdownファイルのみ表示

**時間見積**: 6-8時間

#### フェーズB (実用性向上)
- [ ] アイコン表示 (ディレクトリ/ファイル)
- [ ] サイドバー表示/非表示切り替え (Ctrl+B)
- [ ] 現在開いているファイルの強調表示
- [ ] 遅延読み込み (パフォーマンス改善)

**時間見積**: 4-6時間

#### フェーズC (高度な機能)
- [ ] 右クリックメニュー (外部エディタで開く等)
- [ ] ディレクトリ自動更新 (notify統合)
- [ ] 隠しファイル表示切り替え
- [ ] サイドバー幅の保存

**時間見積**: 6-8時間

**推奨**: フェーズA → B → C の順に段階的実装

**回答**:推奨案でお願いします

---

## ディレクトリツリー機能の決定事項まとめ

### 決定が必要な重要事項 (優先度順)

1. **Q23: 表示範囲とフィルタリング** - ツリーの基本仕様 ✅
2. **Q24: レイアウト構成** - Paned vs Box vs Stack ✅
3. **Q25: ウィジェット選択** - TreeView vs ListView ✅
4. **Q27: ファイル操作** - クリック、ダブルクリック、右クリックの動作 ✅
5. **Q30: 初期ディレクトリ** - 起動時に表示するルート ✅
6. **Q38: 実装優先度** - どのフェーズから着手するか ✅

各質問への回答をお願いします。回答は各セクションの「**回答**:」の後に記載してください。

---

## 追加の確認事項

### Q39: ディレクトリのみ指定した場合の動作
**質問**: CLI引数でディレクトリのみ指定した場合、プレビューエリアには何を表示しますか？

**背景**:
現在の実装は `dogmv <file.md>` でファイル指定のみですが、ディレクトリツリー機能追加に伴い、ディレクトリ指定もサポートする必要があります。

**実行例**:
```bash
# ファイル指定（既存の動作）
dogmv README.md           # → README.mdを開き、その親ディレクトリをツリー表示

# ディレクトリ指定（新しい動作）
dogmv ~/docs/project/     # → ~/docs/project/をルートとしてツリー表示
                          # プレビューエリアは？
```

**選択肢**:

#### A. **空白（何も表示しない）**
- プレビューエリアは空のまま
- ユーザーがツリーからファイルをクリックして開く
- **メリット**: シンプル、予測可能
- **デメリット**: 初期状態が寂しい

#### B. **ディレクトリ内の最初のMarkdownファイルを自動的に開く**
- ディレクトリ内を検索してREADME.md等を自動的に開く
- 検索順序:
  1. `README.md` (大文字小文字区別なし)
  2. `index.md`
  3. アルファベット順で最初の.mdファイル
- **メリット**: すぐに内容が見える
- **デメリット**: 予期しないファイルが開く可能性

#### C. **ウェルカムメッセージを表示**
- HTMLで「ファイルを選択してください」等のメッセージ表示
- 表示例:
  ```
  dogmv - Markdown Viewer

  ← 左側のツリーからMarkdownファイルを選択してください

  キーボードショートカット:
  - Ctrl+O: ファイルを開く
  - Ctrl+R: リロード
  - Ctrl+Q: 終了
  ```
- **メリット**: ユーザーフレンドリー、使い方が分かる
- **デメリット**: 実装コスト増

**推奨**: **B** (最初のMarkdownファイルを自動的に開く) - 実用的で使いやすい

**回答**: ウェルカムメッセージで大丈夫です。

---

### Q40: トグルボタンの配置場所
**質問**: サイドバーの表示/非表示を切り替えるトグルボタンをどこに配置しますか？

**選択肢**:

#### A. **ツールバー（ウィンドウ上部）**
```
┌─────────────────────────────────────────┐
│ [≡] [↻]  dogmv - Markdown Viewer       │ ← タイトルバー
├─────────────────────────────────────────┤
│ [📁] [🔄] [⚙]                           │ ← ツールバー
├──────────┬──────────────────────────────┤
│ ツリー   │ プレビュー                   │
```
- 新しくツールバーウィジェットを追加
- **メリット**: ボタンが目立つ、複数のアクション追加可能
- **デメリット**: 画面縦幅を消費

#### B. **ヘッダーバー（タイトルバー統合）** - GTK4推奨
```
┌─────────────────────────────────────────┐
│ [≡] dogmv - Markdown Viewer     [↻] [⚙]│ ← HeaderBar
├──────────┬──────────────────────────────┤
│ ツリー   │ プレビュー                   │
```
- `gtk4::HeaderBar`を使用
- タイトルバーにボタンを統合
- **メリット**: モダンなGTK4アプリの標準、省スペース
- **デメリット**: なし
- **推奨**: GTK4のベストプラクティス

#### C. **サイドバー上部**
```
┌─────────────────────────────────────────┐
│ dogmv - Markdown Viewer                 │
├──────────┬──────────────────────────────┤
│ [×]      │                              │
│──────────│                              │
│ ツリー   │ プレビュー                   │
```
- サイドバーペイン内にボタン配置
- **メリット**: サイドバーに関連するボタンが明確
- **デメリット**: サイドバーが狭い

#### D. **キーボードショートカットのみ（ボタンなし）**
- Ctrl+Bでトグル
- **メリット**: UIシンプル
- **デメリット**: 発見しにくい

**推奨**: **B (HeaderBar)** - GTK4の標準的なUI、省スペースで見やすい

**実装イメージ**:
```rust
let header_bar = gtk4::HeaderBar::new();

// 左側: サイドバートグルボタン
let toggle_button = gtk4::ToggleButton::with_label("☰");
toggle_button.set_tooltip_text(Some("サイドバー表示切替 (Ctrl+B)"));
header_bar.pack_start(&toggle_button);

// 右側: その他のボタン（将来の拡張用）
// let settings_button = gtk4::Button::with_label("⚙");
// header_bar.pack_end(&settings_button);

window.set_titlebar(Some(&header_bar));
```

**回答**: サイドバー上部としてください。閉じたときも完全にツリービューを閉じるのではなく、左側にツリービュー枠とわかる余白を残し、余白クリックでツリービュー表示するような振る舞いとしてください。

---

### Q41: 現在開いているファイルの追跡
**質問**: 以下の操作で現在開いているファイルを追跡し、ツリービューで強調表示する理解で正しいでしょうか？

**確認する動作**:

1. **CLI引数でファイルを開いた場合**
   ```bash
   dogmv ~/docs/README.md
   ```
   → ツリービューで`README.md`が強調表示される

2. **ツリービューからファイルをクリックした場合**
   ```
   ツリーで「INSTALL.md」をクリック
   ```
   → プレビューが更新され、ツリービューで`INSTALL.md`が強調表示される
   → 以前の`README.md`の強調は解除

3. **Ctrl+Oでファイルダイアログから開いた場合**
   ```
   Ctrl+O → 別ディレクトリの「guide.md」を選択
   ```
   → プレビューが更新され、`guide.md`が強調表示される
   → ツリーのルートが`guide.md`の親ディレクトリに変更される？
   → または、ツリーはそのままで、`guide.md`がツリー外なら強調表示なし？

**質問**: Ctrl+Oで別ディレクトリのファイルを開いた場合、ツリービューはどう動作しますか？

**選択肢**:

#### A. **ツリーのルートを変更**
- 新しく開いたファイルの親ディレクトリをツリーのルートに変更
- **メリット**: 常に開いているファイルがツリーに表示される
- **デメリット**: ツリーが切り替わるため、元のディレクトリが見えなくなる

#### B. **ツリーはそのまま、強調表示なし**
- ツリーのルートは変更しない
- 新しく開いたファイルがツリー内にあれば強調表示、なければ強調なし
- **メリット**: ツリーの状態が保持される
- **デメリット**: 開いているファイルがツリーに見えない場合がある

#### C. **ツリーのルート変更をユーザーに確認**
- ダイアログで「ツリーを新しいディレクトリに切り替えますか？」と確認
- **メリット**: ユーザーが選択できる
- **デメリット**: 操作が煩雑

**推奨**: **A (ツリーのルートを変更)** - シンプルで一貫性がある

**回答**: A案で大丈夫です。

---

### Q42: Markdown以外のファイルのクリック動作
**質問**: ツリービューでMarkdown以外のファイル（.txt, .png等）をクリックした場合の動作を明確にしてください。

**仕様確認**:
- Q23の回答で「すべてのファイルを表示」「Markdown以外をクリックしても何もしない」と決定済み

**詳細な動作**:

#### A. **完全に反応なし**
- クリックイベント自体を無視
- ツリービューの選択状態も変わらない
- **実装**: クリックハンドラーでファイルタイプをチェック、Markdown以外はreturn

#### B. **選択状態にはなるが、プレビューは更新されない**
- ツリービューではファイルが選択された状態（背景色変更等）になる
- プレビューエリアは更新されない（前のファイルのまま）
- **実装**: クリックハンドラーで選択は許可、プレビュー更新のみスキップ
- **メリット**: ユーザーに「クリックは認識されたが開けない」ことを伝えられる

#### C. **選択状態にして、プレビューエリアにメッセージ表示**
- ツリービューでファイルを選択状態にする
- プレビューエリアに「このファイルはプレビューできません」等のメッセージ表示
- **メリット**: 明示的なフィードバック
- **デメリット**: 実装コスト増、前のプレビューが消える

#### D. **外部アプリケーションで開く**
- `xdg-open`でデフォルトアプリケーションで開く
- 画像なら画像ビューア、テキストならエディタ等
- **メリット**: 実用的
- **デメリット**: ビューアの役割を超える

**推奨**: **B (選択状態にはなるが、プレビューは更新されない)** - ユーザーフィードバックとシンプルさのバランス

**視覚的なフィードバック追加案**:
- Markdown以外のファイルはアイコンの色をグレーアウト
- マウスカーソルをホバーした際にツールチップで「プレビュー不可」を表示

**回答**: B案でお願いします。

---

## 追加確認事項の決定優先度

以下の順序で決定をお願いします:

1. **Q40: トグルボタンの配置** - UI設計の基本
2. **Q39: ディレクトリ指定時の動作** - CLI引数仕様の拡張
3. **Q41: ファイル追跡とツリー更新** - 動作の一貫性
4. **Q42: Markdown以外のクリック動作** - エッジケース処理

各質問の「**回答**:」欄に決定内容を記載してください。

---

## 実装仕様の明確化に関する追加質問

### Q43: ツリービューの初期展開状態
**質問**: ディレクトリツリーを初期表示する際、ルートディレクトリ直下のサブディレクトリの展開状態はどうしますか？

**選択肢**:

#### A. **すべて折りたたまれた状態**
- ルートディレクトリ直下のサブディレクトリは全て折りたたまれている
- ユーザーが手動で展開する必要がある
- **メリット**: シンプル、初期表示が高速
- **デメリット**: 階層が深い場合、目的のファイルまで複数回クリックが必要

#### B. **1階層分は自動展開**
- ルートディレクトリ直下のサブディレクトリのみ自動展開
- その下の階層は折りたたまれている
- **メリット**: ディレクトリ構造の概要がすぐわかる
- **デメリット**: ディレクトリ数が多いと初期表示が縦に長くなる

#### C. **現在開いているファイルまでのパスを自動展開**
- 現在開いているファイルが含まれるディレクトリまでのパスのみ展開
- その他のサブディレクトリは折りたたまれている
- **例**:
  ```
  docs/              ← ルート
  ├─ images/         ← 折りたたまれている
  └─ guide/          ← 展開（現在開いているファイルがここにある）
     ├─ intro.md
     └─ setup.md     ← 現在開いているファイル（強調表示）
  ```
- **メリット**: 現在のファイルがすぐ見つかる、必要最小限の展開
- **デメリット**: 実装がやや複雑
- **推奨**: ユーザビリティ最優先

**推奨**: **C (現在開いているファイルまでのパスを自動展開)** - 最も実用的

**回答**: C案でお願いします。

---

### Q44: ファイル名が長い場合の表示
**質問**: 長いファイル名がサイドバー幅を超える場合の表示方法はどうしますか？

**選択肢**:

#### A. **省略記号(...)で切り詰め**
```
very-long-filename-that-ex...
```
- 表示幅に収まるように末尾を省略
- **実装**: GTK4の`Label::set_ellipsize()`

#### B. **ツールチップで完全なファイル名を表示**
- マウスホバー時にツールチップで完全なファイル名を表示
- **実装**: `Widget::set_tooltip_text()`

#### C. **横スクロール可能にする**
- ツリービュー全体を横スクロール可能にする
- **デメリット**: 操作が煩雑

#### D. **折り返し表示**
- 長いファイル名を複数行に折り返す
- **デメリット**: 行の高さが不揃いになる、見づらい

**推奨**: **A + B** (省略記号で表示 + ホバー時にツールチップで全文表示) - 標準的なファイルマネージャと同じUX

**回答**: 推奨案でお願いします

---

### Q45: Q40のトグルボタン配置の詳細仕様
**質問**: Q40で「サイドバー上部にトグルボタン配置」「余白クリックでツリービュー表示」と回答いただきましたが、具体的なUI設計を明確にしたいです。

**確認事項**:

#### 1. サイドバーを閉じた際の「余白」の仕様
- **幅**: 何ピクセル程度を想定していますか？
  - A: 狭い (20-30px程度、アイコンのみ表示可能)
  - B: 中程度 (50-80px程度、縦書きテキスト表示可能)
  - C: ユーザーが決めた幅のまま（Panedの位置を記憶）

- **表示内容**:
  - A: 何も表示しない（空白のみ）
  - B: アイコン（📁等）を縦に配置
  - C: 縦書きで「ファイルツリー」等のテキスト
  - D: 展開ボタン（>や▶等）のみ

#### 2. 余白のクリック動作
- **A**: 余白のどこをクリックしても展開
- **B**: 余白上部の特定のボタンエリアのみクリック可能
- **C**: 余白全体がホバー可能で、クリックで展開

#### 3. 代替案の提示
もし実装が複雑になる場合、以下の標準的な実装も検討可能です：

**代替案1: 完全非表示+ヘッダーバーにトグルボタン**
```
┌─────────────────────────────────────────┐
│ [☰] dogmv - README.md              [⚙] │ ← HeaderBar
├─────────────────────────────────────────┤
│                                         │
│          プレビュー (全画面)             │
│                                         │
```
- サイドバーを閉じたら完全に非表示
- ヘッダーバー左端に[☰]ボタンで再表示
- **メリット**: シンプル、標準的、実装容易

**代替案2: Panedの最小幅設定**
```
┌─────────────────────────────────────────┐
│ dogmv - README.md                       │
├──┬──────────────────────────────────────┤
│[×]│                                     │
│  │        プレビュー                    │
│  │                                     │
```
- `Paned::set_start_child_shrink(false)`で最小幅を確保
- 閉じるボタン[×]のみ表示、クリックで非表示
- 再表示はCtrl+Bのみ（ボタンが消えるため）
- **メリット**: 実装が簡単

**質問**:
- 元の仕様（余白表示）を希望される場合、上記の確認事項1, 2についてご回答ください
- または、代替案1か2を採用する方がよろしいでしょうか？

**推奨**: **代替案1 (完全非表示+ヘッダーバーにトグルボタン)** - GTK4の標準的なパターン、実装容易

**回答**: 余白は最低限で大丈夫です。表示内容は展開ボタンのみ。余白クリック字の動作はボタンエリアのみクリック可能としてください。提案頂いている代替案についてですが、このアプリはnixos/hyprland環境での起動を想定しており、アプリケーション本体のヘッダーバーは表示されない仕様を想定しています。このため、ヘッダーバーにトグルボタンを設置しても想定環境で利用できないため、却下とさせてください。

---

### Q46: 実装開始のタイミング
**質問**: ディレクトリツリー機能の実装をいつ開始しますか？

**選択肢**:

#### A. **すぐに開始 (フェーズAから)**
- 現在の仕様で十分明確なため、実装を開始する
- 不明点があれば実装中に確認

#### B. **全ての仕様を確定してから**
- Q43-Q45の回答を待ってから実装開始
- より詳細な実装計画を立ててから着手

#### C. **プロトタイプを先に作成**
- 簡易版を実装して動作を確認
- その後、詳細な仕様を詰める

**推奨**: **B (全ての仕様を確定してから)** - 手戻りを最小化

**回答**: B案でお願いします。仕様の全容が把握できていない場合は常にQA.mdに追加の質問を記載し、仕様が明確になるまで質問の作業を続けてください。

---

## 確認項目まとめ

以下の質問に回答をお願いします：

1. **Q43**: ツリービューの初期展開状態 → 推奨: C (現在開いているファイルまでのパスを自動展開) ✅
2. **Q44**: 長いファイル名の表示 → 推奨: A + B (省略記号 + ツールチップ) ✅
3. **Q45**: トグルボタンの詳細仕様 → 元の仕様の詳細化 or 代替案採用 ✅
4. **Q46**: 実装開始のタイミング ✅

---

## 回答内容の確認と追加質問

### Q45回答の確認
Q45の回答から以下が明確になりました：
- NixOS/Hyprland環境でヘッダーバーは表示されない
- 余白は最低限（展開ボタンのみ）
- ボタンエリアのみクリック可能

この回答を踏まえて、いくつか追加で確認が必要です。

---

### Q47: Hyprland環境でのウィンドウ装飾
**質問**: Hyprland環境でヘッダーバーが表示されないとのことですが、ウィンドウタイトルバーの扱いはどうしますか？

**背景**:
GTK4アプリケーションでは通常、以下の2つの選択肢があります：

#### A. **Client-Side Decorations (CSD)** - GTK4デフォルト
```rust
window.set_decorated(true);  // GTKが描画するタイトルバー
let header_bar = gtk4::HeaderBar::new();
window.set_titlebar(Some(&header_bar));
```
- GTK4が独自にタイトルバーを描画（HeaderBar）
- Waylandでは標準的
- **しかし、回答によるとHyprlandでHeaderBarは表示されない？**

#### B. **Server-Side Decorations (SSD)** - ウィンドウマネージャが描画
```rust
window.set_decorated(true);  // ウィンドウマネージャが描画
// HeaderBarは設定しない
```
- Hyprlandがタイトルバーを描画
- タイトルバーにはウィンドウタイトルと最小化/最大化/閉じるボタンのみ
- アプリ側ではタイトルバーにボタン等を配置できない

#### C. **装飾なし**
```rust
window.set_decorated(false);  // タイトルバーなし
```
- タイトルバーが一切表示されない
- ウィンドウ移動はHyprlandのキーバインドに依存

**質問**:
1. Hyprland環境では、どのウィンドウ装飾モードを想定していますか？
   - CSD (GTK4のHeaderBar) だが、Hyprlandの設定で非表示にする？
   - SSD (Hyprlandが描画するタイトルバー)？
   - 装飾なし？

2. Q45で「ヘッダーバーは表示されない」とありますが、これは：
   - A: GTK4のHeaderBarを設定しても、Hyprlandの設定で強制的にSSDになる
   - B: アプリ側で`set_decorated(false)`として装飾を無効にする
   - C: その他の理由

**推奨**:
- Waylandの標準に従い、**CSD (HeaderBar使用)** を実装
- Hyprland側の設定で表示/非表示を制御できるようにする
- これにより、他のデスクトップ環境でも正常に動作する

**回答**: もとは装飾なしを想定していましたが、推奨案で大丈夫です。

---

### Q48: トグルボタンの配置場所（Q45の補足）
**質問**: Q45の回答を踏まえ、サイドバーのトグルボタンの具体的な配置を確認します。

**確認した仕様**:
- 余白は最低限（20-30px程度と想定）
- 表示内容は展開ボタン（例: `▶`）のみ
- ボタンエリアのみクリック可能

**UI実装イメージ**:

#### パターンA: サイドバーペイン上部にボタンウィジェット
```
┌─────────────────────────────────────────┐
│ dogmv - README.md                       │  ← Hyprlandのタイトルバー（SSD）
│                                         │     またはHeaderBar（CSD）
├──┬──────────────────────────────────────┤
│▶ │                                      │  ← ▶ボタンクリックで展開
│  │                                      │
│  │         プレビュー                   │
│  │                                      │
```
- サイドバーを閉じると、左端に幅30px程度の縦長エリア
- 上部に`▶`ボタン（gtk4::Button）を配置
- ボタンクリックでサイドバー展開

**実装**:
```rust
// サイドバーコンテナ
let sidebar_box = gtk4::Box::new(gtk4::Orientation::Vertical, 0);

// トグルボタン
let toggle_button = gtk4::Button::from_icon_name("pan-end-symbolic");
toggle_button.set_tooltip_text(Some("サイドバー展開"));
sidebar_box.append(&toggle_button);

// ツリービュー（初期は非表示）
let tree_scroll = gtk4::ScrolledWindow::new();
tree_scroll.set_child(Some(&tree_view));
tree_scroll.set_visible(false);  // 閉じた状態
sidebar_box.append(&tree_scroll);

// Panedに配置
let paned = gtk4::Paned::new(gtk4::Orientation::Horizontal);
paned.set_start_child(Some(&sidebar_box));
paned.set_end_child(Some(&webview));
```

**トグル動作**:
- ボタンクリック → `tree_scroll.set_visible(true)` + アイコンを`pan-start-symbolic`(◀)に変更
- 再度クリック → `tree_scroll.set_visible(false)` + アイコンを`pan-end-symbolic`(▶)に変更

**質問**: この実装イメージで正しいでしょうか？
- A: 正しい、この実装で問題ない
- B: いいえ、別の配置方法を希望する（具体的に記載してください）

**回答**: はい、その実装イメージで正しいです。

---

### Q49: CLI引数でディレクトリを指定する仕様
**質問**: Q23, Q39でディレクトリ指定の動作を決定しましたが、CLI引数の仕様を明確にします。

**現在の仕様（Q18の回答）**:
- `dogmv <file.md>` でファイルパス指定のみ可
- 引数なしの場合はエラー
- 複数ファイルは非対応

**ディレクトリツリー機能追加に伴う変更**:

#### CLI引数のパターン
1. **ファイル指定**
   ```bash
   dogmv README.md
   dogmv ~/docs/project/README.md
   ```
   - 動作: ファイルを開き、親ディレクトリをツリー表示

2. **ディレクトリ指定**
   ```bash
   dogmv ~/docs/project/
   dogmv .
   ```
   - 動作: ディレクトリをツリーのルートとして表示、ウェルカムメッセージ表示

3. **引数なし**
   ```bash
   dogmv
   ```
   - 動作: Q18の回答では「エラー」だが、変更しますか？
   - 選択肢:
     - A: エラーで終了（現行仕様維持）
     - B: カレントディレクトリ(`.`)をルートとして表示
     - C: ファイル選択ダイアログ表示（Q18で却下済み）

**判定方法**:
```rust
use std::path::Path;

let arg = std::env::args().nth(1).expect("引数が必要");
let path = Path::new(&arg);

if path.is_file() {
    // ファイルとして開く
    open_file(path);
    show_tree(path.parent().unwrap());
} else if path.is_dir() {
    // ディレクトリとして開く
    show_tree(path);
    show_welcome_message();
} else {
    // 存在しないパス
    eprintln!("エラー: パスが存在しません");
    std::process::exit(1);
}
```

**質問**:
1. この判定ロジックで問題ないでしょうか？
2. 引数なしの場合の動作を変更しますか？（A, B, C のいずれか）

**推奨**: 引数なしの場合は **B (カレントディレクトリを表示)** - 利便性向上

**回答**: はいその判定ロジックで大丈夫です。Bのカレントディレクトリを表示としてください。

---

### Q50: ウェルカムメッセージの具体的な内容
**質問**: Q39でウェルカムメッセージ表示と決定しましたが、具体的な内容を確定します。

**表示タイミング**:
- ディレクトリ指定で起動した場合
- Ctrl+Oで全てのファイルを閉じた場合（将来的な拡張）

**メッセージ内容案**:

#### 案A: シンプル
```html
<div style="text-align: center; margin-top: 100px; font-family: sans-serif;">
  <h1>dogmv - Markdown Viewer</h1>
  <p style="color: #666;">左側のツリーからMarkdownファイルを選択してください</p>
</div>
```

#### 案B: ショートカット一覧付き（Q39の推奨案）
```html
<div style="text-align: center; margin-top: 50px; font-family: sans-serif;">
  <h1>dogmv - Markdown Viewer</h1>
  <p style="color: #666;">← 左側のツリーからMarkdownファイルを選択してください</p>

  <div style="margin-top: 50px; text-align: left; display: inline-block;">
    <h3>キーボードショートカット:</h3>
    <ul style="list-style: none; padding-left: 0;">
      <li><kbd>Ctrl+O</kbd> : ファイルを開く</li>
      <li><kbd>Ctrl+R</kbd> : リロード</li>
      <li><kbd>Ctrl+Q</kbd> : 終了</li>
    </ul>
  </div>
</div>
```

#### 案C: プロジェクト情報付き
- 上記 + バージョン情報、リポジトリリンク等

**質問**: どの内容を表示しますか？
- A: 案A（シンプル）
- B: 案B（ショートカット一覧付き）
- C: 案C（プロジェクト情報付き）
- D: カスタム（具体的な内容を記載してください）

**推奨**: **B (ショートカット一覧付き)** - ユーザーフレンドリー

**回答**: 推奨案でお願いします。

---

### Q51: ツリービューのアイコン選択
**質問**: Q26で「ファイル名 + アイコン」表示と決定しましたが、使用するアイコンを確定します。

**選択肢**:

#### A. **GTK4標準アイコン (Adwaita Icon Theme)**
```rust
// ディレクトリ
let dir_icon = gio::ThemedIcon::new("folder-symbolic");

// Markdownファイル
let md_icon = gio::ThemedIcon::new("text-x-generic-symbolic");

// その他のファイル
let file_icon = gio::ThemedIcon::new("text-x-generic-symbolic");

// シンボリックリンク
let link_icon = gio::ThemedIcon::new("emblem-symbolic-link");
```
- **メリット**: システムテーマに統合、実装容易
- **デメリット**: Markdownファイル専用のアイコンがない
- **推奨**: 標準的な実装

#### B. **カスタムアイコン**
- SVGアイコンを同梱（例: markdown.svg）
- **メリット**: Markdownファイルが見分けやすい
- **デメリット**: アイコンファイルの管理が必要

#### C. **Unicodeアイコン（絵文字）**
```
📁 docs/
📄 README.md
🔗 link.md (symlink)
```
- **メリット**: 追加ファイル不要、視認性高い
- **デメリット**: フォントに依存、統一感に欠ける可能性

**質問**: どのアイコンを使用しますか？

**推奨**: **A (GTK4標準アイコン)** - システムテーマと統合、実装容易

**回答**: A案でお願いします。

---

## 新規追加質問まとめ

以下の質問に回答をお願いします：

1. **Q47**: Hyprland環境でのウィンドウ装飾 - CSD/SSD/装飾なし ✅
2. **Q48**: トグルボタンの配置（実装イメージの確認） ✅
3. **Q49**: CLI引数でディレクトリ指定する仕様 ✅
4. **Q50**: ウェルカムメッセージの具体的な内容 ✅
5. **Q51**: ツリービューのアイコン選択 ✅

---

## ディレクトリツリー機能の仕様確定

全ての質問に回答をいただきました。以下、確定した仕様をまとめます。

### 確定仕様サマリー

#### 基本仕様
- **表示範囲**: ディレクトリ指定時はそのディレクトリ、ファイル指定時は親ディレクトリ (Q23)
- **フィルタリング**: すべてのファイルを表示 (Q23)
- **ディレクトリ展開**: 展開可能なツリー形式 (Q23)
- **初期展開**: 現在開いているファイルまでのパスを自動展開 (Q43)

#### UIレイアウト
- **レイアウト**: gtk4::Paned（可変幅、初期250px） (Q24, Q31)
- **ウィジェット**: ListView + TreeListModel (Q25)
- **ウィンドウ装飾**: CSD (HeaderBar使用) (Q47)
- **サイドバートグル**: 上部に展開ボタン（▶/◀）、ボタンクリックで表示/非表示 (Q48)

#### 表示内容
- **表示項目**: ファイル名 + アイコン (Q26)
- **アイコン**: GTK4標準アイコン (folder-symbolic, text-x-generic-symbolic等) (Q51)
- **ソート**: ディレクトリ優先 + 名前順（アルファベット順） (Q32)
- **長いファイル名**: 省略記号(...) + ツールチップで全文表示 (Q44)
- **現在のファイル**: 強調表示（ハイライト） (Q37)
- **隠しファイル**: 非表示 (Q33)

#### ファイル操作
- **クリック動作**: シングルクリックでMarkdownファイルを開く (Q27)
- **Markdown以外**: 選択状態にはなるが、プレビューは更新されない (Q42)
- **ディレクトリ操作**: 展開/折りたたみ (Q27)
- **キーボード**: 矢印キー、Enter、文字検索 (Q36)

#### CLI引数仕様
- **ファイル指定**: `dogmv file.md` → ファイルを開き、親ディレクトリをツリー表示 (Q49)
- **ディレクトリ指定**: `dogmv dir/` → ツリー表示、ウェルカムメッセージ (Q49)
- **引数なし**: `dogmv` → カレントディレクトリをツリー表示 (Q49)

#### その他
- **ツリー更新**: 手動（Ctrl+R） (Q28)
- **ファイル追跡**: Ctrl+Oで別ディレクトリのファイルを開いた場合、ツリーのルートを変更 (Q41)
- **ウェルカムメッセージ**: ショートカット一覧付き (Q50)
- **パフォーマンス**: 遅延読み込み (Q35)
- **エラーハンドリング**:
  - 権限エラー: ログ出力のみ (Q34)
  - シンボリックリンク: 辿らず、(symlink)と表示、展開不可 (Q34)

#### 実装フェーズ
- **フェーズA**: 基本機能（Paned配置、ツリー表示、クリック、展開/折りたたみ）
- **フェーズB**: 実用性向上（アイコン、トグル、強調表示、遅延読み込み）
- **フェーズC**: 高度な機能（将来的な拡張）
- **開始**: 全仕様確定後 (Q46)

---

## 最終確認

### 仕様の完全性チェック

以下の観点で仕様が揃っているか確認しました：

1. **技術スタック**: ✅ gtk4-rs, ListView + TreeListModel
2. **UIレイアウト**: ✅ 全て決定済み
3. **表示内容**: ✅ 全て決定済み
4. **操作仕様**: ✅ 全て決定済み
5. **CLI引数**: ✅ 全て決定済み
6. **エラーハンドリング**: ✅ 全て決定済み
7. **実装フェーズ**: ✅ 3段階で実装

### 残された不明点

現時点で実装に必要な仕様は全て確定しています。

追加で確認が必要な項目はありません。

**実装開始の準備が整いました。**
