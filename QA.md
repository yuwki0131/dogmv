# Markdown Viewer 実装に関する Q&A

## 決定済み事項

### ✓ プログラミング言語
**決定**: Rust

---

## 技術選定に関する質問（Rust前提）

### Q1: GUIフレームワーク
**質問**: どのGUIフレームワークを採用しますか？

**Rust対応の選択肢**:

#### 1. **gtk4-rs** (GTK4のRustバインディング)
- **メリット**:
  - Waylandネイティブ対応、Hyprlandとの相性良好
  - 豊富なウィジェット、成熟したエコシステム
  - NixOSでのビルドサポートが充実
  - WebKitGTKと連携してWebViewレンダリング可能
- **デメリット**:
  - FFIバインディングのため、純粋なRustではない
  - 依存関係が多い（GTK4本体が必要）

#### 2. **Iced**
- **メリット**:
  - 純粋なRust実装、型安全性高い
  - Elm風の宣言的UI、状態管理がシンプル
  - wgpu/Vulkan/OpenGLバックエンド選択可能
  - クロスプラットフォーム
- **デメリット**:
  - WebViewサポートが限定的（自前でWebレンダリングが必要）
  - GTK4ほど成熟していない
  - リッチテキストレンダリングが複雑

#### 3. **egui**
- **メリット**:
  - 軽量、イミディエイトモード
  - シンプルなAPI、学習コスト低い
  - wgpuバックエンドでWayland対応
- **デメリット**:
  - WebViewサポートなし
  - Markdownレンダリングを全て自前実装が必要

#### 4. **Slint**
- **メリット**:
  - QMLライクな宣言的UI
  - 軽量、組み込みにも対応
- **デメリット**:
  - Markdownレンダリングの実装例が少ない
  - エコシステムがGTK/Icedより小さい

#### 5. **relm4** (GTK4のRustラッパー)
- **メリット**:
  - gtk4-rsより高レベルなAPI
  - Elmライクな設計でIcedに近い使い勝手
  - GTK4の恩恵を受けつつRustらしい記述
- **デメリット**:
  - gtk4-rsの上に構築されるため、学習コストが二重

**推奨**:
- **WebViewレンダリング採用なら**: `gtk4-rs` または `relm4` (WebKitGTK連携が容易)
- **ネイティブレンダリング採用なら**: `Iced` (純粋Rust、柔軟性高い)

**回答**: gtk4-rsを採用で。

---

### Q2: Markdownパーサー/レンダラー
**質問**: どのMarkdownライブラリを使用しますか？

**Rustの選択肢**:

#### 1. **comrak**
- GitHub Flavored Markdown完全対応
- テーブル、タスクリスト、取り消し線など拡張機能豊富
- HTMLへの変換が容易
- シンタックスハイライト用のコールバック対応
- **推奨**: 機能豊富で実用的

#### 2. **pulldown-cmark**
- 高速、CommonMark厳密準拠
- 軽量、依存少ない
- イベントベースのパーサー（カスタマイズ性高い）
- GFM拡張は限定的（別途`pulldown-cmark-gfm`必要）
- **推奨**: シンプルな実装向け

#### 3. **markdown-rs**
- CommonMark完全実装
- モダンな設計
- エコシステムがやや小さい

**決定**: `comrak` (GFM対応、拡張性、実績から)

---

## 機能要件に関する質問

### Q5: ファイル監視機能
**質問**: ファイルが外部エディタで変更された際、自動的にリロードしますか？

**Rust実装における選択肢**:

#### 1. **notify** crate使用（自動リロード）
- クロスプラットフォームなファイル監視
- inotify (Linux) 使用で低オーバーヘッド
- **実装**: 非同期タスクでファイル変更監視 → UIに通知
- **メリット**: ライブプレビュー体験
- **デメリット**: 頻繁な変更時のパフォーマンス影響

#### 2. 手動リロードのみ
- `Ctrl+R`やリロードボタン
- **メリット**: シンプル、予測可能
- **デメリット**: 手動操作が必要

#### 3. 変更検知 + 通知バー
- ファイル変更を検知してバナー表示
- ユーザーがクリックでリロード
- **メリット**: 自動/手動のバランス
- **推奨**: 初期実装向け

**推奨**: **notify + 自動リロード**（開発体験向上のため）

**回答**: **notify + 自動リロード**（開発体験向上のため）でOKです。
---

### Q3: レンダリング方式
**質問**: HTMLレンダリング方式は？

**Rust実装における選択肢**:

#### A. **WebView方式** (webkit2gtk-rs使用)
- **実装**:
  1. `comrak`でMarkdown → HTML変換
  2. `webkit2gtk-rs`でHTMLレンダリング
- **メリット**:
  - CSSによるスタイリング容易
  - 画像、リンク、テーブルの表示が簡単
  - ブラウザと同じ見た目
- **デメリット**:
  - WebKitGTKの依存必須（サイズ大）
  - GTK4前提（他のフレームワークと組み合わせ困難）
- **推奨ケース**: GTK4採用時、開発速度優先

#### B. **ネイティブウィジェット方式** (GTKウィジェット直接)
- **実装**:
  1. `comrak`のイベントパーサーを使用
  2. GTKの`TextView`, `Label`, `Image`等でレンダリング
- **メリット**:
  - WebKit不要、軽量
  - システムテーマと完全統合
- **デメリット**:
  - 実装が複雑（リッチテキスト処理）
  - CSSが使えない
- **推奨ケース**: 軽量化優先、WebKit依存を避けたい場合

#### C. **カスタムレンダリング** (wgpu + コスモポリタン2D)
- **実装**:
  1. Iced/eguiのカスタムウィジェット
  2. `cosmic-text`などでテキストレンダリング
  3. 独自のレイアウトエンジン
- **メリット**:
  - 完全な制御、最適化可能
  - GTK不要、純粋Rust
- **デメリット**:
  - 実装コストが極めて高い
  - 画像、テーブル等の実装が困難
- **推奨ケース**: 高度なカスタマイズ、将来的な拡張性重視

**推奨**: **WebView方式（GTK4 + webkit2gtk-rs）**
- 理由: 開発速度、機能性、NixOS/Hyprlandとの親和性

**回答**: 推奨されているA案で大丈夫です。

---

### Q4: シンタックスハイライト
**質問**: コードブロックのシンタックスハイライトをどう実装しますか？

**Rust実装における選択肢**:

#### 1. **syntect** (WebView方式で推奨)
- Sublime Textのシンタックス定義（.sublime-syntax）使用
- 200以上の言語サポート
- HTML出力が容易（`<span class="...">`でマークアップ）
- **統合例**: `comrak` → `syntect`でコードブロック処理 → HTMLに埋め込み
- **推奨**: WebViewレンダリング採用時

#### 2. **tree-sitter** + カスタムハイライト
- 高速、正確な構文解析
- インクリメンタルパース可能
- **課題**: HTML変換やスタイリングを自前実装必要
- **推奨**: ネイティブレンダリング採用時

#### 3. **highlight.js** (WebView内で実行)
- JavaScript実装、WebView内で動作
- CDNから読み込み可能
- **メリット**: Rust側の実装不要
- **デメリット**: JSに依存、ビルドサイズ増
- **推奨**: 最小限の実装で済ませたい場合

#### 4. ハイライトなし
- コードブロックをモノスペースフォントで表示のみ

**推奨**: **syntect**（WebView方式採用時）
**回答**: 推奨されている1案(syntect)で大丈夫です。

---

## NixOS固有の質問

### Q6: Nixパッケージング
**質問**: どのようにパッケージングしますか？

**Rust + Nixの選択肢**:

#### 1. **flake.nix + Cargo.toml** (推奨)
- `crane`を使用したRustビルド
- Cargoの依存解決 + Nixの再現性
- **構成**:
  - `flake.nix`: パッケージ定義、開発環境
  - `Cargo.toml/Cargo.lock`: Rust依存管理
- **メリット**: 両エコシステムの利点を活用

#### 2. `buildRustPackage`のみ
- nixpkgs標準のRustビルド
- **メリット**: シンプル
- **デメリット**: `crane`より柔軟性低い

**推奨**: **flake.nix (crane) + shell.nix**
**回答**: 推奨されている1案(flake.nix/cargo.toml)で大丈夫です。
---

### Q7: システムライブラリ依存（GTK4採用時）
**質問**: GTK4/WebKitGTKなどのシステムライブラリをどう扱いますか？

**Nixでの実装**:
```nix
buildInputs = [
  gtk4
  webkitgtk_6_0
  pkg-config
];
```

**確認事項**:
- GTK4のWaylandバックエンドが有効か（NixOSではデフォルト有効）

- `webkitgtk_6_0`の利用可否（GTK4対応版）
- Hyprland環境変数（`GDK_BACKEND=wayland`）

**推奨**: `shell.nix`と`flake.nix`両方でビルド依存を明記

---

## UI/UX に関する質問

### Q8: ウィンドウレイアウト
**質問**: UIレイアウトは？

**選択肢**:

#### 1. **プレビュー単一画面**
- ファイルオープン → 全画面プレビュー表示
- ファイル選択は`FileChooserDialog`またはCLI引数
- **メリット**: シンプル、Unix哲学（ファイルマネージャと分離）
- **推奨**: 初期実装向け

#### 2. **サイドバー付き**
- 左: ファイルツリー、右: プレビュー
- **メリット**: 複数ファイル切り替えが容易
- **デメリット**: 実装複雑化

#### 3. **分割ビュー（エディタ + プレビュー）**
- 左: テキストエディタ、右: プレビュー
- **課題**: エディタ実装が必要（スコープ拡大）
- **推奨しない**: Viewerの範囲を超える

**推奨**: **プレビュー単一画面**
**回答**: 初期実装は1のプレビュー単一画面とします。ただし将来的にはサイドバー(左にファイルツリー)をつける予定です。
---

### Q9: テーマ・スタイリング
**質問**: 見た目のカスタマイズ性は？

**GTK4実装の場合**:

#### 1. **GTKテーマ追従** (推奨)
- `gtk4::Settings::default()`でシステムテーマ自動適用
- Adwaita、Adwaita-dark等に対応
- **実装**: 特別な設定不要

#### 2. **カスタムCSS**
- GTK4の`CssProvider`でスタイル上書き
- Markdown表示部分のフォント、色をカスタマイズ
- **例**: コードブロックの背景色、フォントサイズ
- **実装**: `style.css`を読み込み

#### 3. **WebView内CSS** (WebView採用時)
- HTMLに`<style>`タグでCSS注入
- `webkit2gtk`の`load_html`時にスタイル適用
- **推奨**: GitHub風スタイルなど選択可能にする

**推奨**: **GTKテーマ追従 + WebView内カスタムCSS**
**回答**: WebView内CSSとしてください。
---

### Q11: キーボードショートカット
**質問**: どのようなキーバインドを実装しますか？
**例**:
- `Ctrl+O`: ファイルを開く
- `Ctrl+R`: リロード
- `Ctrl+Q`: 終了
- `Ctrl++/-`: ズーム

**不明点**: Hyprland固有のキーバインドとの競合回避
**回答**: 初期実装では以下のみ実装してください。ただし、将来的にはキーショートカットの拡充(変更)を行います
- `Ctrl+O`: ファイルを開く
- `Ctrl+R`: リロード
- `Ctrl+Q`: 終了

---

## パフォーマンス・最適化

### Q12: 大規模ファイル対応
**質問**: 大きなMarkdownファイル（数MB以上）の扱いは？
**考慮点**:
- 遅延レンダリング
- 仮想スクロール
- ファイルサイズ制限

**不明点**: 実用上の最大ファイルサイズ目安
**回答**:2000行(60k程度)を目安にしてください。平均は100〜1000行程度のmarkdownを開く想定です。
---

### Q13: メモリ管理
**質問**: 画像やアセットのキャッシュ戦略は？
**選択肢**:
- メモリキャッシュ
- ディスクキャッシュ
- キャッシュなし

**回答**: メモリキャッシュ

---

## 拡張機能・将来計画

### Q14: プラグイン機構
**質問**: 将来的にプラグインや拡張機能をサポートしますか？
**例**:
- カスタムMarkdown拡張
- テーマプラグイン
- エクスポート機能

**回答**: プラグイン拡張はしない(想定しない)でお願いします。

---

### Q15: エクスポート機能
**質問**: MarkdownをPDF/HTML/その他形式にエクスポートしますか？
**優先度**: 低〜中

**回答**: エクスポートは不要です。純粋なViewのみの機能を提供します。

---

## 開発プロセス

### Q16: テスト戦略
**質問**: どのようなテストを実施しますか？
**種類**:
- ユニットテスト（Markdownパース、レンダリングロジック）
- 統合テスト
- GUIテスト（難易度高）

**回答**: ひとまずUnitテストでお願いします。

---

### Q17: CI/CD
**質問**: 継続的インテグレーションを設定しますか？
**選択肢**:
- GitHub Actions（Nix環境でのビルド）
- 手動ビルド

**回答**: 将来的にはGitHub Actionsでの稼働を想定しますが、一旦初期実装はローカルの手動ビルドを想定してください。

---

## アプリケーション仕様の詳細

### Q18: CLI引数仕様
**質問**: コマンドライン引数の仕様はどうしますか？

**選択肢**:

#### 1. ファイルパス指定
```bash
dogmv <file.md>
dogmv /path/to/document.md
```
- 引数でファイルパスを受け取り、そのファイルを開く

#### 2. 引数なしの場合
- **A**: ファイル選択ダイアログ（GTK FileChooserDialog）を表示
- **B**: エラーメッセージ表示して終了
- **C**: 空のウィンドウ表示、Ctrl+Oでファイルを開く

#### 3. 複数ファイル対応
```bash
dogmv file1.md file2.md file3.md
```
- 初期実装では不要？
- 将来的にタブ機能と組み合わせ？

**推奨**:
- `dogmv <file.md>` でファイル直接開く
- 引数なしの場合はファイルダイアログ表示
- 複数ファイルは初期実装では非対応

**回答**: 引数ありでファイルパス指定のみ可としてください。それ以外の引数は不要です。また、初期実装では複数ファイル対応も不要です。

---

### Q19: エラーハンドリング
**質問**: エラーケースの扱いはどうしますか？

**エラーケース**:

#### 1. 存在しないファイルパス
```bash
dogmv non_existent.md
```
- **A**: エラーダイアログ表示 + ファイル選択ダイアログ
- **B**: stderr出力して終了
- **C**: エラーダイアログ表示して終了

#### 2. Markdown以外のファイル
```bash
dogmv document.txt
dogmv image.png
```
- **A**: 拡張子チェックせず、テキストとして開く（寛容）
- **B**: `.md`, `.markdown`のみ受け付ける（厳格）
- **C**: 警告を出すが開く

#### 3. 読み込み権限がないファイル
- **A**: エラーダイアログ表示
- **B**: stderr出力して終了

#### 4. 破損したMarkdown/不正なUTF-8
- **A**: ベストエフォートでレンダリング（comrakのデフォルト動作）
- **B**: エラー表示

**推奨**:
- 存在しないファイル: エラーダイアログ + ファイル選択ダイアログ
- Markdown以外: 拡張子チェックせず開く（寛容）
- 権限エラー: エラーダイアログ表示
- 破損データ: ベストエフォートでレンダリング

**回答**: 存在しないファイルの場合はエラーログ出力でダウン(プロセスを中断し終了)で大丈夫です。Markdown以外のファイルを開くことを試みた場合、権限エラー、破損データの場合もエラーログ出力で強制中断で大丈夫です。ただし、単にMarkdownフォーマットとして崩れている場合はそのまま生テキストとして表示させてください。

---

### Q20: 画像パスの解決
**質問**: Markdown内の画像パス（相対パス/絶対パス）の扱いはどうしますか？

**パターン**:

#### 1. 相対パス
```markdown
![](./images/foo.png)
![](../assets/bar.png)
```
- **基準ディレクトリ**: 開いたMarkdownファイルの親ディレクトリ
- WebView内で`file://`スキームで解決

#### 2. 絶対パス
```markdown
![](/home/user/images/baz.png)
```
- そのまま解決

#### 3. HTTP/HTTPS URL
```markdown
![](https://example.com/image.png)
```
- **A**: WebViewで自動ダウンロード・表示（WebKitの機能）
- **B**: セキュリティ理由で無効化
- **C**: 設定で切り替え可能

#### 4. ベースURL設定
- HTMLレンダリング時に`<base href="file:///path/to/markdown/dir/">`を設定
- 相対パス解決を自動化

**推奨**:
- 相対パス: Markdownファイルのディレクトリを基準に解決
- 絶対パス: そのまま使用
- HTTP/HTTPS: WebViewデフォルト動作（表示する）
- `<base>`タグで自動解決

**回答**: 相対パスで。

---

### Q21: ウィンドウサイズ・状態の保存
**質問**: ウィンドウのサイズや位置を記憶しますか？

**選択肢**:

#### 1. 状態保存あり
- 前回のウィンドウサイズ、位置を保存
- 保存先: `~/.config/dogmv/window.conf` など
- GTK4の`gtk::Window::save_size()`使用

#### 2. 状態保存なし
- 常にデフォルトサイズで起動（例: 1024x768）

#### 3. 最後に開いたファイルを記憶
- 引数なし起動時に前回のファイルを開く

**推奨**:
- 初期実装: 状態保存なし（デフォルトサイズ）
- 将来: ウィンドウサイズ保存

**回答**: 状態保存なしで。

---

### Q22: ログ出力・デバッグ
**質問**: ログ出力の方針は？

**選択肢**: ログは起動したターミナルに直接出力してください。

#### 1. ログライブラリ
- **env_logger**: 環境変数`RUST_LOG=debug`でログレベル制御
- **tracing**: 構造化ログ、デバッグに有用

#### 2. ログ出力先
- **A**: stdout/stderr
- **B**: ファイル (`~/.cache/dogmv/dogmv.log`)

#### 3. ログレベル
- エラー、警告、情報、デバッグ

**推奨**:
- `env_logger` + `log` crate
- stdout/stderr出力
- `RUST_LOG=dogmv=debug`で詳細ログ

**回答**:ログレベルは一旦初期実装ではエラー、警告、情報、デバッグログまで全部出力で問題ないです。出力先も標準出力でOKです。

---

---

## 決定事項まとめ（ユーザー入力待ち）

### ✓ 確定済み
- **言語**: Rust
- **Markdownパーサー**: comrak

### ⚠ 決定が必要な重要事項

以下の項目について決定をお願いします：

#### 1. **GUIフレームワーク** (Q1)
- [ ] **gtk4-rs** (WebView連携容易、NixOS親和性高)
- [ ] **Iced** (純粋Rust、カスタマイズ性高)
- [ ] **その他** (relm4, egui, Slint)

#### 2. **レンダリング方式** (Q3)
- [ ] **WebView** (webkit2gtk-rs、開発速度優先)
- [ ] **ネイティブウィジェット** (GTK4ウィジェット直接、軽量)
- [ ] **カスタムレンダリング** (高度、実装コスト大)

#### 3. **その他の方針** (任意)
- ファイル監視: 自動リロード / 手動 / 通知バー (推奨: 自動)
- シンタックスハイライト: あり / なし (推奨: syntect使用)
- ウィンドウレイアウト: 単一画面 / サイドバー (推奨: 単一)


回答は各セクションに記載しました。各セクションの内容を確認してください。

---

### 推奨構成（迷った場合）
```
言語: Rust
GUIフレームワーク: gtk4-rs
レンダリング: WebView (webkit2gtk-rs)
Markdownパーサー: comrak
シンタックスハイライト: syntect
ファイル監視: notify (自動リロード)
レイアウト: プレビュー単一画面
パッケージング: flake.nix + Cargo
```

この構成なら、NixOS/Hyprland環境で実用的なMarkdownビューアが実装できます。
